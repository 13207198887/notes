{"meta":{"title":"Notebook","subtitle":null,"description":"A messy notebook.","author":"程振兴","url":"http://www.czxa.top"},"pages":[{"title":"","date":"2018-07-03T13:27:16.181Z","updated":"2017-11-30T06:16:09.433Z","comments":true,"path":"404.html","permalink":"http://www.czxa.top/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"","date":"2018-01-10T05:58:08.000Z","updated":"2018-07-30T03:17:50.018Z","comments":true,"path":"about/index.html","permalink":"http://www.czxa.top/about/index.html","excerpt":"","text":"👇我的坐标"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2017-01-11T18:24:34.000Z","comments":true,"path":"archives/index.html","permalink":"http://www.czxa.top/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-10-17T00:21:44.000Z","updated":"2018-07-12T06:06:35.252Z","comments":true,"path":"categories/index.html","permalink":"http://www.czxa.top/categories/index.html","excerpt":"","text":""},{"title":"我的收藏夹","date":"2017-11-22T23:58:08.000Z","updated":"2018-07-28T08:38:55.444Z","comments":true,"path":"favorites/index.html","permalink":"http://www.czxa.top/favorites/index.html","excerpt":"","text":"这里是我收藏的一些有用好玩的网站 各种图表库 danvk/dygraphs: 使用JavaScript+HTML时间序列的交互可视化 dygraphs.com ecomfe/awesome-echarts: Awesome list of echarts ant-design/ant-design: 🐜 A UI Design Language Mapbox GL：地图可视化 C3.js图表库 amCharts图表库 ZingChart图表库 Chart.js图表库 Stata绘图 vis.js图表库 Stata用户绘图 d3/d3: Bring data to life with SVG, Canvas and HTML. NVD3图表库 D3可视化 AntV教程 ECharts教程 d3js 地图数据 D3.js - Data-Driven Documents 可视化笔记本 y-takey/atom-mermaid: Preview mermaid on atom editor tauCharts图表库 ElemeFE/v-charts: 基于 Vue2.0 和 ECharts 封装的图表组件📈📊 Taucharts图表库 安装 - v-charts hadley (Hadley Wickham) idre-Stata图表 NJC-Stata图表 ECharts示例 谷歌图表 Ant Motion - Ant Design 的动效规范与组件 highcharts中文网站 蚂蚁金服数据可视化 easychart rumble-charts图表库 VictoryChart ChartNew.js-Demo program FancyGrid Gallery Jelly-Chart AnyChart picasso.js 在终端显示bitcoin的走势图 Matplotlib 可视化R包&amp;Python包 R语言可视化学习笔记之ggrepel包 friendly/heplots: (R包)在多元线性模型中可视化假设检验 R中的圆形可视化 kassambara/ggpubr: 基于&#39;ggplot2&#39;可用于出版物中的绘图方案 在R Shiny app中插入ECharts可交互图表 Python+ECharts绘图包 bokeh/bokeh: Python中的交互网络绘图 ggtree包 常用R包列表 hrbrmstr/waffle: 在R中绘制华夫图（平方饼图） hrbrmstr/hrbrthemes: Opinionated, typographic-centric ggplot2 themes and theme components rstudio/d3heatmap: A D3.js-based heatmap htmlwidget for R knoema绘图工具 顺序图的语法和功能 mermaid-以类似于降价的方式从文本生成图表和流程图 镝次元 pheatmap: R中绘制热力图 一个可视化GO浓缩结果的R包作为文字云，并将它们与实验数据图一起排列 大佬的博客 一个数据可视化大佬的个人网站 Stata大佬WILLIAM MATSUOKA的个人博客 贝林·查韦斯的个人网站（stata/R） The Stata Blog Stata | 代码和文化 一个R/Stata大佬的博客 好看的图表 ECharts：阶梯瀑布图 使用D3.js绘制甘特图. 双向柱子图 SPMAP: Stata module to visualize spatial data List of GIS tools for Stata DEVTOOLS: Tools for stata developers Stata官方教程-spmap命令绘制地图 2018世界杯参赛国家 中国热力图 水球图+环图 高德地图省市下钻 分区域颜色设置 力导向图 pyecharts - A Python Echarts Plotting Library 各种网站 图片转HTML（可以用来绘制Stata图片的背景图） 1990年苹果系统模拟 自定义手势操作的软件的使用教程 使用IntelliJ运行Scala教程 在 macOS 上安装 TensorFlow 15分钟，学会 Markdown 免费的计算机编程类中文书籍 TensorFlow中文社区 ECharts-Java使用Java快速开发ECharts图表-博客-云栖社区-阿里云 R资源大全中文版来了，全球最火的R工具包一网打尽，超过300+工具，还在等什么？ python-scraping 模板实验室 音乐搜索器 - 多站合一音乐搜索,音乐在线试听 CRAN官网 python3 爬虫https的坑 Python包：Statsmodels Examples 统计预测：回归与时间序列分析 利用python进行时间序列分析——季节性ARIMA mac OS版 QQ 小助手, 功能: 消息防撤回&amp;自动回复&amp;Alfred扩展 期货从业人员资格考试网上报名 故事书软件 http-server-npm官网 网页限制解除 移除百度搜索的广告 WiseDoge/ProxyPool: 跨语言IP代理池，Python实现。 TKkk-iOSer/WeChatPlugin-MacOS: MacOS版微信小助手 Carbon—一个分享代码图片的网站 程振兴&#39;s Résumé 下载免费的字体 | Fonts4Free NotePlan for Mac 1.6.24 -支持Markdown的精益简单设计日历 微博开放平台 MetricsGraphics.js fusioncharts 12 Best Charting Libraries for Web Developers nvd3 chartjs jqplot chartist.js xcharts d3.js zrender 图悦-在线词频分析工具-词云图制作软件 图表秀——免费在线图表制作工具,数据可视化工具 HTML5词云 WordArt.com - 单词艺术的创造者 Wordle - 好看的词云 中文文本分析方便工具R包chinese.misc的中文说明 cran/praise:专门点赞的R包 A first ado-command using Mata mac命令行压缩解压rar文件 Linux命令搜索引擎 WinRAR archiver, a powerful tool to process RAR and ZIP files rename 命令：用字符串替换的方式批量改变文件名 unsplash网站 乔布简历 latexstudio sharelatex latextemplates 免费的许多学术文章的程序与资料 微信工具箱 Alfred 2 Workflow List workflows Sublime Text3配色 CTex社区：可以下载很多Latex模板 微博API 国家哲学社会科学文献中心：可以免费下载很多文献 随机图片接口 linux命令查询 科学软件网：可以下载一些软件的试用版 Stata官网提供的一些Stata15新功能的学习 lantern最新版下载地址 把Excel表格转成HTML表格的在线工具 天天美剧：一个可以下载到很多美剧的网站 爱情守望者：一个可以下载到很多免费的Mac软件的网站 史蒂芬周的博客 从pan.baidu.com获取下载链接，您无需害怕禁止您的帐户 数据分析软件 IBM SPSS Statistics 25 for macOS&amp;Windows&amp;Linux-落尘之木博客 Tonido 打造你的个人网盘 落尘之木博客—破解软件下载 我的coding R包搜索 在线工具 一个ado文件库 谷歌动图 markdown插入图片 制作自己的小图标 一个前端程序员的个人网站 sumup.ado clean.ado egenmisc(非常强大的egen函数拓展) bytwoway.ado showtext：字体，好玩的字体和好玩的图形 在线工具——开源中国社区：里面有正则表达式测试、编码转换、CSV转HTML表格等功能 R包的帮助文档网站 Sublime Text3 在配置的时候需要运行的一段代码 下载图标的一个网站 webimage：在Stata中将网页文件转换为图形图像 猎数博客：一个emacs、markdown、R、Python等都用的很棒的人 R包开发：在线版 通过修改网址中的相应参数可以获取相应城市相应年份的房价走势图 GARP登陆页面：FRM注册 Stata官网推荐的Stata学习书籍 WGestures全局鼠标手势 r-exec：在Atom中运行R R包开发的官方教程 像素小图标的创建网址 Travis-ci：还没弄懂干嘛的 Github装逼指南——Travis CI 和 Codecov curl：可以模拟网页登陆的命令行工具 curl教程 Everything curl：在线版 Stata &amp; Java：看到了在Stata中实现MD5算法的希望 Windows下wget安装与使用方法 wget下载源 油猴脚本 mac下命令行安装wget 一个Stata大佬的网站 Stata shell “command not found” errors Windows下的 Axel下载工具 在Markdown中插入腾讯视频的插件 ggmap包：ggmap使得从流行的在线地图服务中检索栅格地图图块变得很容易，并使用ggplot2框架绘制它们 statar包：在R语言中使用Stata语言 reghdfe命令：具有多个固定效应的线性回归 MarkDoc是Stata的通用文字编程软件包，可以创建动态分析文档，动态演示文稿幻灯片以及动态Stata帮助文件和软件包文档 statacpp：用于在do-files中嵌入C++代码 Markdown中实现缩进的方法 html-slides org-mode之入门篇 GFM Markdown Wysiwyg Editor - Productive and Extensible Alibaba的GitHub Radial Bar Chart Generator for Apple Watch awesome-macos-command-line Awesome Hyper 在终端显示天气预报 漂亮的终端配色 在终端查询天气 终端配色 油猴脚本下载 Latex字符查询 Mac版QQ音乐绿砖破解 Mac系统下的QQ抢红包插件 百度网盘命令行工具 Convert PPT to xaringan (remark.js) Slides 百度网盘 破解SVIP、下载速度限制 下载微博图片的Python脚本 修改 WebStorm 里面丑陋的 Markdown 样式 RStata包 用来排版书籍的R包 R语言网页数据爬取rvest包学习 Python在终端装好包以后，在Pycharm中依然无法使用解决办法 python+selenium个人学习笔记8-获取信息和勾选框 tesseract-ocr/tesseract: Tesseract Open Source OCR Engine (main repository) 查看R程序的执行进度 matlab-monokai Tesseract的各国语言包 Mac上文字识别(Tesseract-OCR for mac ) 制作自己的字体 pornhub爬虫Python脚本 pornhub视频爬虫和pornhub视频下载url爬虫 Download videos from pornhub Mac OS 利用launchctl开机运行python程序 华硕F454L安装黑苹果简单记录 掘金社区：一个程序员的社区 python数据框基本操作 Python 资源大全中文版 joinquant社区：量化投资学习 一个金融大佬的GitHub仓库 Python包：yagmail发送邮件 Beautiful Soup 4.4.0 文档 python使用sqlalchemy连接mysql数据库 利用pandas实现从数据库读写数据 Excel=&gt;Html atom报错&quot;Cannot load the system dictionary for zh-CN&quot; 永久免费翻樯大杀器(不限速) 云盘精灵 Excel [原创] Excel插件—数据图表 Markdown-syntax 创造狮数据源 应用计量经济学——时间序列分析数据集 Packt出版社数据集 可以用于分时数据爬取 国内生产总值(GDP)-宏观数据-财经频道_证券之星 70 个大中城市住宅销售价格-工业数据-财经频道_证券之星 新增信贷数据一览-宏观数据-财经频道_证券之星 中财网数据引擎 新浪财经—爬取分时数据 7×24小时全球实时财经新闻直播_直播_财经_新浪网 中国货币网--中国外汇交易中心主办 行情中心_新浪财经_新浪网 数据总览 | 上海证券交易所 深圳证券交易所 行业关注详情_腾讯财经_腾讯网 中国1年期债券收益率 - Investing.com 融资融券交易总量 基金经理 _ 天天基金网 2017年中国人口结构现状及人口年龄结构对房地产行业的影响分析 新房价指数详情 _ 数据中心 _ 东方财富网 微信通讯录导出 itchat包爬取微信好友列表 itchat包教程 比价中心-外汇频道-和讯网 knoema数据库——可爬 统计年鉴分享平台 新三板做市信息 矢量图标数据库 Stata Journal 资源汇总 R语言自动数据收集的配套代码数据 多元时间序列分析及其金融应用 UCI机器学习数据集 FRED经济数据库 国泰安数据库 pm2.5数据 知网：中国人口年鉴1985-2015:是本书 2010年第六次人口普查数据：可以直接下载Excel文件 2000年第五次人口普查数据：可以直接下载Excel文件 联合国人口司数据源 A Visual Guide to Stata Graphics, Third Edition 安永研究报告 华人姓氏查询 暨南大学教务处 Tradingeconomics: 这个网址上有很多可以爬的东西 东方财富网：可以爬到很多经济数据 knoema数据库——可爬 比特币实时交易数据 有道词典的机器翻译结果是可爬的 微指数：可爬 搜狗指数：不仅可爬，还可以写成命令 中房网：可以爬到一些房地产数据 历史朝代表：可以爬一爬 历史上的今天：可以爬一爬 和讯数据：可以爬取到很多数据 Ａ股所有公司基本概况一览表 Ａ股所有公司收入状况一览表 所有公司分红状况一览表 暨南大学能耗查询系统 财富网：500强数据 百度汉语：可爬 百度音乐 酷狗音乐 5sing原创音乐基地 网易云音乐 12306车票查询 爬爬ssc上的所有命令 有哪些「神奇」的数据获取方式？ 暨南大学图书外借排行榜 国家外汇管理局新版国际互联网站 Automated Data Collection with R - Book Materials 全网音乐免费下载 大数据导航|大数据从业者的网址大全-学大数据，就上大数据人导航！ UNSD数据 Knoema数据库 中国货币网 图书 GitHub 漫游指南 Chrome扩展及应用开发（首发版）-图书-图灵社区 计算机相关技术书籍 CRAN下载每个包的页面 Mastering Markdown · GitHub Guides 自定义 CSS - Markdown Preview Enhanced Emoji cheat sheet for GitHub, Basecamp and other services 2017-2018年FRM考试教材及资料汇总下载 CRAN上的R包分类 程序相关书籍 很多免费的电子书下载 selenium入门 阿尔法量化 Tushare -财经数据接口包 一个股票数据（沪深）爬虫和选股策略测试框架，数据基于雅虎YQL和新浪财经 掘金策略集锦 一款自动化交易框架, 可以在其基础上 架设自己的策略交易系统 QUANTAXIS 从数据爬取-清洗存储-分析回测-可视化-交易复盘的本地一站式解决方案 博客素材 来比力：在博客中插入评论功能 Hexo的Next主题介绍 iTimeTraveler的收藏品 在Hexo中插入easy chart图表 Hexo文章的词语计数插件 在Hexo中插入谷歌地图的插件 在Hexo中添加echarts图表 Hexo主题：St. Andrews Hexo Next 主题点击加载 Disqus 和来必力双评论系统 hexo实现二级和多级菜单的方法 把hexo部署到coding上乱码 Anisina 中文使用教程 Hexo：Hueman主题 valine：评论系统 Hexo多终端(系统)同步撰写博客 Hugo-theme-introduction Jekyll Hugo-tracks-theme Hugo-elate-theme Hugo Themes Base16 Hugo-nederburg-theme corazon主题 jekyll-theme-prologue jekyll-material-theme jekyll-massively-theme jekyllthemes-Type-on-Strap jekyllthemes-jekflix jekyllthemes-windows-95 jekyllthemes-flexible-jekyll jekyllthemes-panelcvagain jekyllthemes-event-jekyll-theme jekyllthemes-Liberxue-Theme jekyllthemes-bef jekyllthemes-panelcv jekyllthemes-dactl jekyllthemes-basically-basic jekyllthemes-bheema jekyllthemes-karna jekyllthemes-Avalon jekyllthemes-slides jekyllthemes-hexo-theme-gal 微信推文收藏 复杂数据处理（下）：1816-2013年拉萨年平均气温变化分析（附数据集） ggstance：ggplot2的水平版本 快来给这个图表起个名字吧~ R语言向量化运算：apply函数族用法心得 Kaggle：纽约的士旅程数据简要分析 复杂数据处理（上）：航班航行距离与延误时间的关系 Get新技能，利用gglot2画环形图 实证结果输出命令 数据地图多图层对象的颜色标度重叠问题解决方案 ggplot2中如何自定义数据地图版面范围 leaflet的小搭档leaflet.minicharts来了，从此动态地图又多了一些乐趣 Word天呀，气泡图居然还有这种操作~ 你想要的地图素材资源，我都帮你整理好了~ 学会自定义主题，让你的仪表盘瞬间高逼格~ 对，你没看错，真的有这种操作~ 送你两款炫酷到没朋友的神奇字体~ ggplot2多维分面多图层对应规则 美美的商务范儿——ggplot2蝴蝶图 仿经济学人——矩阵气泡图 商务图表案例——仿经济学人分组漏斗图~ Kaggle：纽约的士旅程数据简要分析 时间函数——从毫秒计算其他单位的时间（1） 用R语言对空气质量进行可视化分析 R语言中文社区历史文章整理（类型篇） R语言交互式绘制杭州市地图：leafletCN包简介 R语言文本挖掘1——词云制作，基于Rwordseg包 R语言实战：利用算法识别糖尿病患者 为“Tidyverse”疯狂打call！ 我用Python爬取了全国4500个热门景点，告诉你国庆哪儿最堵？ 批量合并多张excel表，VBA帮助解决大麻烦 经济管理 计量经济学软件 课件 资料 免费下载 MatchingFrontier包简介及R实现 用R语言实现深度学习情感分析 用Zhihu-OAuth库轻松爬取知乎各类数据 闪电约会数据 RCurl中这么多get函数，是不是一直傻傻分不清！！！ R语言爬虫实战：知乎live课程数据爬取实战 把 Chrome 定制成强大的利器 | 美化终极教程 ggplot2双坐标轴的解决方案 数据预处理中的缺失值问题 R文本分类之RTextTools 简书文章收藏 Sublime插件：增强篇 Stata兄弟：提问时能否有点诚意？用 dataex 吧 markdown的流程图、时序图、甘特图画法 Fuzzy Differences-in-Differences （模糊倍分法） 如何处理时间序列中的日期间隔 (with gaps) 问题？ Stata快捷键GIF：键盘就是你的武器 ggplot2高级绘图 使用ggplot2做PCA图 Omnigraffle技巧整理（翻译和收录） OmniGraffle教程（二） omnigraffle 教程（一） 相见恨晚的Mac技巧（二） 相见恨晚的Mac技巧（一） 如何解封Mac内置的几十款小游戏 一些很实用的Safari浏览器技巧，让你不再考虑Mac上的其他浏览器 如何自动生成文献的引用格式（Mendeley） Chrome 插件：阅读模式 Gephi绘制微博转发图谱：以“@老婆孩子在天堂”为例 如何做一个好色之“图”(2)：从 ggthemes 提取经济学人的图表配色 Stata: 如何检验分组回归后的组间系数差异？ Stata 字符相关基本操作和处理 如何科学地蹭热点：用python爬虫获取热门微博评论并进行情感分析 如何高效的使用Mac？ 程序员的Mac入门-如何查看/显示隐藏文件/文件夹 程序员的Mac入门-调整 Launchpad 应用图标排列方式/软件图标合并 简单认识XPath及在R语言中的简单应用 Markdown CSS 利用python统计《十九大报告》中的关键词和词频 R语言滴水穿石系列文章（一）：dplyr-高效的数据变换与整理工具 利用reshape2包进行数据逆透视和数据透视 R语言的plyr包简介 开心二则：公众号开通原创与可视化神器RAW You-Get——基于Python3的媒体下载工具 多少年了，终于可以和 Evernote 说拜拜 知道这20个正则表达式，能让你少写1,000行代码 把Safari当chrome用（插件篇） 在 Markdown 中使用 HTML 特殊符号 R语言学习笔记之相关性矩阵分析及其可视化 R语言可视化学习笔记之相关矩阵可视化包ggcorrplot R语言可视化之UpSetR包 用circlize包绘制circos plot Kaggle泰坦尼克号之灾1--数据分析 recharts 事件河流图 Graphs-绘制均值的误差棒 (ggplot2) recharts 折线/面积图 recharts 条形/柱形图 recharts 散点图 Scatterplot recharts 词云图 用数据可视化之美逼死密集恐惧症 一篇关于国旗与奥运会奖牌的可视化笔记 R语言可视化学习笔记之ggrepel包 R语言可视化学习笔记之添加p-value和显著性标记 R语言可视化学习笔记之ggpubr包 tmux-让你完全脱离鼠标的终端神器 R语言之数据可视化---酷炫可交互地图REmap R语言之数据可视化---D3可交互图表及流程图 recharts 和弦图 recharts 力导向布局图 获取百度云真实链接，从此下载不再是龟速 LaTeX入门 使用Tensorflow建立RNN实战：股市预测 Mac 下iterm2配色方案（高亮）及显示分支 Mac 下安装运行Rocket.chat (2017.10.24) Mac开发环境配置之HomeBrew 【8分钟】 Mac 下终端配色 不用代码，10分钟会采集微博、微信、知乎、58同城数据和信息 近三十年6000部国产电视剧告诉了我们些什么|R爬虫可视化第四季 Org-mode的电子表格的简明教程 Stata：Mata 笔记 Mac OS 环境下同步备份 知乎文章收藏 为什么很多人认为编辑器比 IDE 更酷？ 手把手教你批量读取数据文件 手把手教你做文本挖掘 如果赌博输赢的概率都是50％，为什么长久赌博的人多会倾家荡产而不是收益均衡？ 左手用R右手Python系列17——CSS表达式与网页解析 左手用R右手Python系列16——XPath与网页解析库 左手用R右手Python系列——模拟登陆教务系统 R实战案例：利用算法识别糖尿病患者（R语言实现） CNN预测股票走势基于Tensorflow（思路+程序） 有哪些很好玩而且很有用的 R 包？ 如何用Vim优雅的写C++ ？ 【数据获取】爬虫利器Rvest包 有哪些很好玩而且很有用的 R 包？ 【干货】Quantitative Finance 杂志关于量化交易领域排名前十的文章 数据预处理中的缺失值问题 卫视实时收视率对比 | R爬虫&amp;amp;可视化第1季 使用R语言对照片人物进行情绪分析 2017年搭建hexo博客如何解决seo问题？ 怎么在 Excel 上做数据地图？ PowerMap, Excel领域的可视化人间凶器 教你在Mac上用Python玩微信跳一跳 iText 新年新版：截图识别文字后，翻译为 100+ 种语言 【新年快乐，跨年文章】Python+百度API 画出美美哒热力地图 用python爬取qq好友十万条说说并简单进行数据分析 R-ggridges包的改进 SpaceVim - 让你的vim变得更加高效和强大 不经意间又发现了一个有趣又炫酷的包~ 各领域公开数据集下载 Matlab如何从曲线图中提取原始数据 时间序列数据工具timekit R语言抓取知乎外拍帖美图 当PowerBI遇到R语言 R语言图表美化——巧用分面表达优化图表布局，做出堪比杂志级视觉体验的商务图表 R语言可视化——ggplot绘制中心密度辐射图 R语言可视化——案例综合运用 云课堂Excel课程数据可视化分析 shiny动态仪表盘应用——中国世界自然文化遗产可视化案例 在哪里能找到各行业的分析研究报告？ R语言爬虫实战——知乎live课程数据爬取实战 R语言数据清洗实战——复杂数据结构与list解析 高维分面应用——ggplot2分面气泡图饼图 金融小知识——CRS风暴与全球离岸金融中心 教师利器：ZoomIt 4.5 屏幕缩放小软件 R语言爬虫实战——网易云课堂数据分析课程板块数据爬取 左手用R右手Python系列14——日期与时间处理 左手用R右手Python系列12——空间数据可视化与数据地图 用R语言把数据玩出花样 R语言可视化——数据地图离散百分比填充（环渤海） 挖掘R包关系网 ggplot2绘制漂亮的直方图 用ggplot轻松搞定太极图 大数据分析社区第3关--某汽车融资租赁公司季度数据分析 ggplot2又添新神器——ggthemr助你制作惊艳美图 使用R绘制热力地图 山东省2016年公共财政收支数据可视化 在R中使用 Prophet 是时候展现真正的技术了——动态人口结构金字塔变化图（R语言+Excel） emojifont包的基本介绍（译文） Python实现文字转语音功能 如何使用自己的编程能力提高生活质量？ 经管类核心期刊地域分布数据可视化 上帝视角——给世界一个特写~ R语言中国地图绘制 实习僧招聘网爬虫数据可视化 流量结构分布图——桑基图（Sankey） R语言挖掘《金刚狼3》影评 【QQ/微信个人号变身机器人】炸群+远程监控个人PC的尝试 R语言爬虫可视化——用数据来聊聊2017年首周各大城市空气质量 shiny仪表盘应用——2016年美国大选数据可视化案例 你绝对想不到，数据地图还能这么玩~ R语言爬虫数据可视化——用数据来聊聊国产电影~ R|ggplot2(一)|一个完整的绘图流程 GDP越高，人们的生活越幸福吗？ 像电影一样记录数据可视化（R语言GIF动图） 记录数据可视化的每一个瞬间 谷歌地图与ggplot2系统如何无缝对接 一个小案例，教你如何从数据抓取、数据清洗到数据可视化 在天猫网页上抓取数据和分析情况报告 零基础如何学爬虫技术？ 在哪里能找到各行业的分析研究报告？ 十个优质SAS网络学习资源分享 手把手教你使用ggplot2进行数据分布探索 使用ggplot2绘制饼图 一个蛇精病的R语言包，每天给你一个花式自动赞~ 利用R语言制作出14种漂亮的交互数据可视化 【量化基础】R语言获取金融数据之quantmod包 R语言分析老九门到底谁是主角 一小时掌握R语言数据可视化 R语言天气可视化应用 R语言如何画个性化词云图 有哪些很好玩而且很有用的 R 包？ 该如何学习 R 语言？ MATLAB 有什么奇技淫巧？ 人工智能(AI)资料大全 用R语言进行NBA赛况分析 ggplot2构造连环饼图 ggplot2构造绩效跟踪的甘特图 科研画图都用什么软件？ 北京历史天气可视化 R数据处理|基础篇（一） 关于ggplot2包的基本功能介绍(下） ggplot2构造漏斗图 使用R语言对照片人物进行情绪分析 R语言如何绘制这种图？ 此库在手，好片无忧！Python爬片，小手不抖 第二版：统计分析/机器学习吐血整理最强指南 怎么样考取Tableau的资格证（Tableau Qualified Associate Exam）？ Java入门学习路径和书籍推荐 读了几千本书，最能点亮头脑的30本在这里 如何给Excel设置动态登陆密码？ 婚前协议和熟人社会--社交网络的经济含义"},{"title":"标签","date":"2017-10-17T00:12:45.000Z","updated":"2018-07-12T05:44:10.374Z","comments":true,"path":"tags/index.html","permalink":"http://www.czxa.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Inreoducing the Series and DataFrame","slug":"Inreoducing_the_Series_and_DataFrame","date":"2018-07-29T16:57:32.000Z","updated":"2018-07-30T03:07:36.192Z","comments":true,"path":"posts/49419/","link":"","permalink":"http://www.czxa.top/posts/49419/","excerpt":"This blog is the first note of Master Pandas for finance . This notes introduce the basics of the Series and DataFrame objects.","text":"This blog is the first note of Master Pandas for finance . This notes introduce the basics of the Series and DataFrame objects. The Basics of The Series and DataFrame ObjectsCreating a Series and accessing elementsIt;s very easy to use numpy create a pandas Series:1234import numpy as npimport pandas as pdnp.random.seed(1)s = pd.Series(np.random.randn(100)) Individual elements of a series can be retrieved using the [] operator of the series object. The item with the index label 2 can be retrieved using the following code:12345s[2]## Multiple values can be retrieved using an array of label values, as shown here:s[[2, 5, 20]]## A series supports slicing using : slice notation.s[3:8] ## Include 3 but not 8 The .head() and .tail() methods are provided by pandas to examine just the first or the last few records in s Series. By default, these return the first five orlast five rows, respectively, but you can use the n parameter or just pass in an interger to specify the number of rows.12s.head()s.tail() Retrieve index and values1234## Retrieve indexs.index## Retrieve valuess.values Note the type of index and values:1234type(s.index)Out[23]: pandas.core.indexes.range.RangeIndextype(s.values)Out[24]: numpy.ndarray Creates a series and set the index:12345678s2 = pd.Series([1, 2, 3, 4], index = ['a', 'b', 'c', 'd'])s2Out[25]:a 1b 2c 3d 4dtype: int64 A series can be directly initialized from a Python dictionary123456789s3 = pd.Series(&#123;'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e':5&#125;)s3Out[26]:a 1b 2c 3d 4e 5dtype: int64 Size, shape, uniqueness, and counts of valueslength123s = pd.Series([10, 0, 1, 1, 2, 3, 4, 5, np.nan])len(s)Out[27]: 9 shape: return a tuple which contain the object’s dimension12s.shapeOut[28]: (9,) count: the count of elements declude from NaN12s.count()Out[29]: 8 unique values in a series12s.unique()Out[30]: array([ 10., 0., 1., 2., 3., 4., 5., nan]) Obtaining the count of each of the unique items in a series.Also declude from NaN:12345678910s.value_counts()Out[31]:1.0 25.0 14.0 13.0 12.0 10.0 110.0 1dtype: int64 Alignment via index labels12s3 = pd.Series([1, 2, 3, 4], index = ['a', 'b', 'c', 'd'])s4 = pd.Series([4, 3, 2, 1], index = ['d', 'c', 'b', 'a']) The process of adding two Series objects differs from an array as it first aligns data upon the index label values instead of simple applying the operations to elements in the same position.12345678s3 + s4Out[35]:a 2b 4c 6d 8dtype: int64 While for numpy array:12345a1 = np.array([1, 2, 3, 4])a2 = np.array([4, 3, 2, 1])a1 + a2Out[36]: array([5, 5, 5, 5]) Creating a DataFramethe most straightforward method is creating it from a NumPy array:123456pd.DataFrame(np.array([[10, 11], [20, 21]]))Out[37]: 0 10 10 111 20 21 A DataFrame can also be initialized by passing a list of Series objects:1234567df1 = pd.DataFrame([pd.Series(np.arange(10, 15)), pd.Series(np.arange(15, 20))])df1Out[40]: 0 1 2 3 40 10 11 12 13 141 15 16 17 18 19 the demensions of it:12df1.shapeOut[39]: (2, 5) column names can be specified at the time of creating the DataFrame using the columns parameter of the DataFrame constructor:1234567891011df = pd.DataFrame(np.array([[10, 11], [20, 21]]), columns = ['a', 'b'])df Out[41]: a b 0 10 11 1 20 21df.columnsOut[42]: Index(['a', 'b'], dtype='object') change the column names:123456df.columns = ['c1', 'c2']dfOut[43]: c1 c20 10 111 20 21 columns and index123456df = pd.DataFrame(np.array([[0, 1], [2, 3]]), columns=['c1', 'c2'], index = ['r1', 'r2'])dfOut[45]: c1 c2r1 0 1r2 2 3 A DataFrame can also be created by passing a dictionary containing one or more Series objects, where the dictionary keys contain the column names and each Series is one column of data.12345678910s1 = pd.Series(np.arange(1, 6, 1))s2 = pd.Series(np.arange(6, 11, 1))pd.DataFrame(&#123;'c1': s1, 'c2': s2&#125;)Out[46]: c1 c20 1 61 2 72 3 83 4 94 5 10 注意：如果直接用数组和序列创建数据框，原来的数组和序列都是按行排列的，但是如果使用字典创建数据框会按列排列。A DataFrame also does automatic alignment of the data for each Series passed in by a dictionary:123456789s3 = pd.Series(np.arange(12, 14), index=[1, 2])pd.DataFrame(&#123;'c1': s1, 'c2': s2, 'c3': s3&#125;)Out[47]: c1 c2 c30 1 6 NaN1 2 7 12.02 3 8 13.03 4 9 NaN4 5 10 NaN Example dataFirst I use TuShare package create a DataFrame df:1234567891011121314151617181920212223242526272829303132333435363738import tushare as tsdf = ts.get_k_data('000001')df.head()Out[54]: date open close high low volume code0 2015-12-15 9.577 9.489 9.624 9.441 364487.0 0000011 2015-12-16 9.537 9.465 9.561 9.457 392762.0 0000012 2015-12-17 9.529 9.608 9.664 9.521 648274.0 0000013 2015-12-18 9.577 9.736 9.991 9.569 1022944.0 0000014 2015-12-21 9.664 9.959 10.126 9.640 1281142.0 000001df.indexOut[55]: RangeIndex(start=0, stop=641, step=1)## 可以比较下面两个用法的小区别：#############################################df['date'].head(3)Out[63]:0 2015-12-151 2015-12-162 2015-12-17Name: date, dtype: objectdf[['date']].head(3)Out[64]: date0 2015-12-151 2015-12-162 2015-12-17#############################################df[['date', 'open']]Out[57]: date open0 2015-12-15 9.5771 2015-12-16 9.537.. ... ...640 2018-07-30 9.320[641 rows x 2 columns] Selecting columns of a DataFrame123456789101112df.date.head(3)Out[59]:0 2015-12-151 2015-12-162 2015-12-17Name: date, dtype: objectdf[['date', 'open']].head(3)Out[60]: date open0 2015-12-15 9.5771 2015-12-16 9.5372 2015-12-17 9.529 Slecting rows of a DataFrame using the indexSlicing using the [] operator1234567df[:3]Out[65]: date open close high low volume code0 2015-12-15 9.577 9.489 9.624 9.441 364487.0 0000011 2015-12-16 9.537 9.465 9.561 9.457 392762.0 0000012 2015-12-17 9.529 9.608 9.664 9.521 648274.0 000001 Slecting rows by the index label and location .loc[] &amp; .iloc[]if DataFrame has a numeric index， .loc[] &amp; .iloc[] have same function：12345678910111213141516171819202122232425262728293031323334353637383940414243444546df.loc[14]Out[100]:date 2016-01-05open 8.972close 9.075high 9.21low 8.876volume 663269code 000001Name: 14, dtype: objectdf.loc[[12, 13]]Out[101]: date open close high low volume code12 2015-12-31 9.632 9.545 9.656 9.537 491258.0 00000113 2016-01-04 9.553 8.995 9.577 8.940 563497.0 000001df.iloc[14]Out[102]:date 2016-01-05open 8.972close 9.075high 9.21low 8.876volume 663269code 000001Name: 14, dtype: objectdf.iloc[[12, 13]]Out[103]: date open close high low volume code12 2015-12-31 9.632 9.545 9.656 9.537 491258.0 00000113 2016-01-04 9.553 8.995 9.577 8.940 563497.0 000001df.index = df.datedf.loc['2018-06-20']Out[105]:date 2018-06-20open 9.713close 9.752high 9.792low 9.605volume 763637code 000001Name: 2018-06-20, dtype: objectdf.iloc[[1]]Out[106]: date open close high low volume codedate 2015-12-16 2015-12-16 9.537 9.465 9.561 9.457 392762.0 000001 It’s possible to look up the location in index of a specific label value, which can be used to retrieve the row(s):12345678i1 = df.index.get_loc('2018-06-20')i2 = df.index.get_loc('2018-06-21')df.iloc[[i1, i2]]Out[107]: date open close high low volume codedate 2018-06-20 2018-06-20 9.713 9.752 9.792 9.605 763637.0 0000012018-06-21 2018-06-21 9.772 9.703 9.880 9.703 840070.0 000001 Selecting rows by the index label and/or location - .ix[]the method is deprecated. please use .loc[] for label based indexing or .iloc[] for positional indexing.df.ix[[‘2018-06-20’, ‘2018-06-21’]]df.ix[[1, 2, 3]] Scalar lookup by label or location using .at[] and .iat[]Scalar values can be looked up by label using .at[] by passing the row label and then the column name/value:1234df.at['2018-06-20', 'open']Out[114]: 9.7129999999999992df.iat[0, 0]Out[115]: '2015-12-15' Selecting rows using the Boolean selection123456789101112131415df.open &lt; 10Out[118]:date2015-12-15 True·····2018-07-30 TrueName: open, Length: 641, dtype: booldf[df.open &lt; 8]Out[119]: date open close high low volume codedate 2016-01-27 2016-01-27 7.905 7.865 7.945 7.642 569037.0 000001······2016-03-02 2016-03-02 7.762 8.040 8.064 7.738 676613.0 000001open = df[df.open &lt; 9][['open']] Arithmetic on a DataFrame1234567891011121314151617181920212223242526np.random.seed(123456)df = pd.DataFrame(np.random.randn(5, 4), columns = ['A', 'B', 'C', 'D'])dfOut[11]: A B C D0 0.469112 -0.282863 -1.509059 -1.1356321 1.212112 -0.173215 0.119209 -1.0442362 -0.861849 -2.104569 -0.494929 1.0718043 0.721555 -0.706771 -1.039575 0.2718604 -0.424972 0.567020 0.276232 -1.087401df * 2Out[12]: A B C D0 0.938225 -0.565727 -3.018117 -2.2712651 2.424224 -0.346429 0.238417 -2.0884722 -1.723698 -4.209138 -0.989859 2.1436083 1.443110 -1.413542 -2.079150 0.5437204 -0.849945 1.134041 0.552464 -2.174801df = df - df.iloc[0]subframe = df[1:4][['A', 'B']]subframeOut[15]: A B1 0.743000 0.1096492 -1.330961 -1.8217063 0.252443 -0.423908 The following demonstrates subtraction along a column axis by using the DataFrame object; the .sub() method subtracts the A column from every column123456789101112131415161718dfOut[16]: A B C D0 0.000000 0.000000 0.000000 0.0000001 0.743000 0.109649 1.628267 0.0913962 -1.330961 -1.821706 1.014129 2.2074363 0.252443 -0.423908 0.469484 1.4074924 -0.894085 0.849884 1.785291 0.048232a_col = df['A']df.sub(a_col, axis = 0)Out[17]: A B C D0 0.0 0.000000 0.000000 0.0000001 0.0 -0.633351 0.885267 -0.6516032 0.0 -0.490745 2.345090 3.5383973 0.0 -0.676351 0.217041 1.1550494 0.0 1.743968 2.679375 0.942316 Reindexing the Series and DataFrame objectsThe process of performing a reindex does the following: Reorders existing data to match a set of labels; Inserts NaN markers where no data exists for a label; Fills missing data for a label using a type of logic(defaulting to adding NaNs) 12345678910111213141516171819np.random.seed(1)s = pd.Series(np.random.randn(5))sOut[21]:0 1.6243451 -0.6117562 -0.5281723 -1.0729694 0.865408dtype: float64s.index = ['a', 'b', 'c', 'd', 'e']sOut[23]:a 1.624345b -0.611756c -0.528172d -1.072969e 0.865408dtype: float64 Creater flexibility in creating a new index is provide using the .reindex() method. One example of flexibility of .reindex() over assigning the .index property directly is that the list provided to .reindex() can be of a different length than the number of rows in the Series:12345678910s2 = s.reindex(['a', 'c', 'e', 'g'])s2Out[26]:a 1.624345c -0.528172e 0.865408g NaNdtype: float64s['a']Out[27]: 1.6243453636632417 注意下面的两个序列由于索引格式不一致而无法对应相加1234567891011121314151617s1 = pd.Series([0, 1, 2], index = [0, 1, 2])s1Out[30]:0 01 12 2dtype: int64s2 = pd.Series([3, 4, 5], index = ['0', '1', '2'])s1 + s2Out[32]:0 NaN1 NaN2 NaN0 NaN1 NaN2 NaNdtype: float64 把索引变成数值型索引之后即可相加12345678910111213s2Out[34]:0 31 42 5dtype: int64s2.index = s2.index.values.astype(int)s1 + s2Out[36]:0 31 52 7dtype: int64 FillingThe default action of inserting NaN as a missing value during .reindex() can be changed using fill_value of the method. The following command demonstrates using 0 instead of NaN:1234567891011121314sOut[39]:a 1.624345b -0.611756c -0.528172d -1.072969e 0.865408dtype: float64s2 = s.copy()s2.reindex(['a', 'f'], fill_value = 0)Out[41]:a 1.624345f 0.000000dtype: float64 前向填充：使用前面的一个元素填充The following command demonstrated forward filling, often referred to as the last known value. The Series is reindexed to create a continuous integer index, and using the method = ‘ffill’ parameter, any new index labels are assigned a value from the previously seen value value along the Series. Here’s the command:1234567891011s3 = pd.Series(['red', 'green', 'blue'], index = [0, 3, 5])s3.reindex(np.arange(0, 7), method = 'ffill')Out[43]:0 red1 red2 red3 green4 green5 blue6 bluedtype: object 后向填充：使用后一个值填充，如果没有则使用缺失值填充12345678910s3.reindex(np.arange(0, 7), method = 'bfill')Out[44]:0 red1 green2 green3 green4 blue5 blue6 NaNdtype: object","categories":[{"name":"Pandas","slug":"Pandas","permalink":"http://www.czxa.top/categories/Pandas/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.czxa.top/tags/Python/"}]},{"title":"A machine learning odyssey","slug":"A_machine_learning_odyssey","date":"2018-07-21T15:49:32.000Z","updated":"2018-07-28T08:38:55.438Z","comments":true,"path":"posts/27977/","link":"","permalink":"http://www.czxa.top/posts/27977/","excerpt":"As the begining of the book, the chapter introduce some basic elements in machine learning and TensorFlow. As I always do, I will just extract some interesting parts and enclose my opinions. Now, let’s we begin!","text":"As the begining of the book, the chapter introduce some basic elements in machine learning and TensorFlow. As I always do, I will just extract some interesting parts and enclose my opinions. Now, let’s we begin! Distance metricsLet’s we have two feature vectors, $x = (x_1, x_2, x_3, \\cdots, x_n)$ and $y = (y_1, y_2, y_3, \\cdots, y_n)$. The Euclidian distance $||x - y||$ is calculated by : $$\\sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2 + \\cdots + (x_n - y_n)^2}$$ Scholars call this the L2 norm. But that’s is just one possible distance functions. The L0, L1, and L-infinity norms also exist. All these norms are valid ways to measure distance. Here they are in detail: The L0 norm counts the total number nonzero elements of a vector. For example, the distance between the origin (0, 0) and vector (0, 5) is 1, because there is only one nonzero element. The L0 distance between (1, 1) and (2, 2) is 2, because neither dimension matches up. Imagine that the first and second dimensions represent username and password, repectively. If the L0 distance between a login attempt and the true credentials is 0, the login is sucessful. If the distance is 1, then either the username or password is incorrect, but not both. Lastly, if the distance is 2, both username and password aren’t found in the database. The L1 norm, shown the in following figure 1.7, is defined as $\\sum{|x_n|}$. The distance between two vectors under L1 norm is also referred to as the Manhattan distanse. Imagine living in a downtown area like Manhattan, New York, where the streets form a grid. The shortest distance from one intersection to another is along the blocks. Similarly, The L1 distance between two vectors is along the orthogonal directions. The distance between (0, 1) and (1, 0) under L1 norm is 2. Computing the L1 distance between two vector is the sum of absolute differences at each dimension, which is a useful measure of similarity. The L2 norm shown in figure 1.8, is the Euclidian length of a verctor. The LN norm generalizes this pattern, resulting in $(\\sum{|x_n|^N})^{1/N}$ The L-infinity norm is $(\\sum{|x_n|^\\infty})^{1/\\infty}$. More naturally, it’s the lagerest magnitude among each element. If the vector is (-1, -2, -3), the L-infinity norm is 3. If a feature vector represents costs of various items, minimizing the L-infinity norm of the vector is an attempt to reduce the cost of the most expensive item. Types of learningSupervised learningBy definition, a supervisor is someone higher up in the chain of command. When we’re in doubt, out supervisor dictates what to do. Likewise, supervised learning is all about learning from examples laid out by a supervisor (such as a teacher). Unsupervised learningUnsupervised learning is about modeling data that comes without corresponding labels or reponses. The fact that we can make any conclusions at all on raw data feels like magic. With enough data, it may be possible to find patterns and structure. Two of the most powerful tools that maching-learning practitioners use to learn from data alone are clustering and dimensionality reduction. Clustering is the process of splitting the data into individual buckets of similar items. One of most popular clustering algorithms is k-means, which is a specific instance of a more powerful technique called the E-M algorithm. Dimensionality reduction is about manipulating the data to view it under a much simpler perspective. It’s the ML equivalent of the phrase, “Keep it simple. stupid.”. One of the earliest algorithms is principle component analysis (PCA), and a newer one is autoencoders. Reinforcement learningUnlike supervised learning, where training data is conveniently labeled by a “teacher”, reinforcement learning trains on information gathered by observing how the environment reacts to actions. Reinforcement learning is a type of machine learning that interacts with the environment to learn which combination of actions yields the most favorable results. Because we’ re already anthropomorphizing algorithms by using the words environment and action, scholars typically refer to the system as an autonomous agent. Therefore, this type of ML naturely manifests itself in the domain of robotics. To the reason about agents in the environment, we introduce two new concepts: states and actions. The status of the world frozen at a particular time is called a state. An agent may perform one of many actions to change the current state. To drive an agent to perform actions, each state yields a corresponding reward, An agent eventually discovers the expected total reward of each state, called the value of s state. The only information an agent knows for certain is the cost of a series of actions that it has already taken, which is incomplete. The agent’s goal is to find a sequence of actions that maximizes rewards. TensorFlowThe structure of this book:","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://www.czxa.top/categories/TensorFlow/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.czxa.top/tags/Python/"}]},{"title":"Python for Finance——入门到放弃","slug":"Python_for_Finance——入门到放弃","date":"2018-06-24T06:49:32.000Z","updated":"2018-07-05T02:46:57.334Z","comments":true,"path":"posts/43149/","link":"","permalink":"http://www.czxa.top/posts/43149/","excerpt":"本文PDF版本下载：Python_for_Finance——入门到放弃.pdf这个是这本书的最后一篇笔记了。。。我看的是第一版的，2013年出的书，太老了，很多代码都运行不下去，所以打算换本新一点的书看。本篇内容是Chapter 8 开头部分。主要介绍了pandas和statsmodels包。","text":"本文PDF版本下载：Python_for_Finance——入门到放弃.pdf这个是这本书的最后一篇笔记了。。。我看的是第一版的，2013年出的书，太老了，很多代码都运行不下去，所以打算换本新一点的书看。本篇内容是Chapter 8 开头部分。主要介绍了pandas和statsmodels包。 使用pandas和statsmodels使用Pandas生成一个数据框1234567891011121314151617181920import numpy as npimport pandas as pddates = pd.date_range('20130101', periods = 5)datesnp.random.seed(12345)x = pd.DataFrame(np.random.rand(5, 2), index = dates, columns = ('A', 'B'))xx.describe() # 显示x的每一列的描述性统计量y = pd.Series([0.1, 0.02, -0.03, np.nan, 0.130, 0.125]) # y contains a NAyy.mean()y.fillna(y.mean()) # fillup y's NA with its mean valueOut[12]:0 0.1001 0.0202 -0.0303 0.0694 0.1305 0.125dtype: float64 statsmodels使用示例——OLS123456789import statsmodels.api as smimport numpy as npy = [1, 2, 3, 4, 2, 3, 4]x = range(1, 8) # x is from 1 to 7x = sm.add_constant(x) # 给x添加一列全为1的列，同时x又range变成ndarrayxr = sm.OLS(y, x).fit() # OLSr.paramsOut[13]: array([ 1.28571429, 0.35714286]) 数据录入从剪贴板获取数据12import pandas as pddata = pd.read_clipboard() # 从剪贴板上读取数据(在此之前我复制了平安银行的数据) 从txt文件中读取数据123import pandas as pdx = pd.read_table('ff_month.txt')x 从Excel中读取数据123import pandas as pdinfile=pd.ExcelFile('pingan.xlsx') # 这里可能会出错，需要安装xlrdx=infile.parse('Sheet1',header=0) 从csv中读取数据12import pandas as pdf = pd.read_csv('pingan.csv') ##收益率的计算1234567import numpy as npp = np.array([1, 1.1, 0.9, 1.05])print(p[1:]) # 去掉第一个print(p[:-1]) # 去掉最后一个ret = (p[1:]-p[:-1])/p[:-1][ 1.1 0.9 1.05][ 1. 1.1 0.9] 例如绘制平安银行的收益率分布图12345678910111213141516171819202122import numpy as npimport tushare as tsfrom matplotlib.pyplot import *from matplotlib.finance import *import matplotlib.mlab as mlabfrom matplotlib.font_manager import *pingan = ts.get_k_data('000001')close = np.array(pingan.close)p_ret = (close[1:]-close[:-1])/close[:-1]myfont = FontProperties(fname='/Library/Fonts/Songti.ttc')matplotlib.rcParams['axes.unicode_minus'] = False[n, bins, patches] = hist(p_ret, 100)mu = np.mean(p_ret)sigma = np.std(p_ret)x = mlab.normpdf(bins, mu, sigma)plot(bins, x, color = 'red', lw = 2)title(u\"平安银行收益率分布\", fontproperties = myfont)xlabel(u\"收益率\", fontproperties = myfont)ylabel(u\"频率\", fontproperties = myfont)rcParams['savefig.dpi'] = 800savefig('20180624a1.png')show()","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.czxa.top/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.czxa.top/tags/Python/"}]},{"title":"Python for Finance Chapter 7","slug":"Python_for_Finance_Chapter_7","date":"2018-06-23T17:49:32.000Z","updated":"2018-07-05T02:46:57.329Z","comments":true,"path":"posts/43798/","link":"","permalink":"http://www.czxa.top/posts/43798/","excerpt":"本文PDF版本下载：Python_for_Finance_Chapter_7.pdfChapter介绍了matplotlib包的使用，内容较多，所有单独记作一篇博客。不过因为这本书是第一版，内容很老了，所以很多代码没办法运行了，很多图画不出来了。","text":"本文PDF版本下载：Python_for_Finance_Chapter_7.pdfChapter介绍了matplotlib包的使用，内容较多，所有单独记作一篇博客。不过因为这本书是第一版，内容很老了，所以很多代码没办法运行了，很多图画不出来了。 一个简单的示例123456789from matplotlib.pyplot import *rcParams['savefig.dpi'] = 600rcParams['figure.dpi'] = 600plot([1,2,3,10])xlabel('x-axis')ylabel('y-axis')title('My figure')savefig('20180623a1.png')show() 数学函数12345678from pylab import *rcParams['savefig.dpi'] = 800rcParams['figure.dpi'] = 800x = np.linspace(-np.pi, np.pi, 256, endpoint = True)C, S = np.cos(x), np.sin(x)plot(x, C), plot(x, S)savefig(\"20180623a2.png\")show() 散点图123456789import numpy as nprcParams['savefig.dpi'] = 600rcParams['figure.dpi'] = 600n = 1024X = np.random.normal(0, 1, size = n)Y = np.random.normal(0, 1, size = n)scatter(X, Y)savefig('20180623a3.png')show() 单利与复利1234567891011121314151617181920212223from matplotlib.font_manager import *from pylab import *# 定义自定义字体，文件名从查看系统中文字体中来myfont = FontProperties(fname='/Library/Fonts/Songti.ttc')# 解决负号'-'显示为方块的问题matplotlib.rcParams['axes.unicode_minus'] = FalsercParams['savefig.dpi'] = 600 # 图片像素rcParams['figure.dpi'] = 600 # 分辨率pv, n, r = (1000, 10, 0.08)t = np.linspace(0, n, n)y1 = np.ones(len(t))*pv # 一条水平参考线y2 = pv*(1+r*t)y3 = pv*(1+r)**ttitle(u\"单利vs复利\", fontproperties = myfont)xlabel(u\"期数\", fontproperties = myfont)ylabel(u\"值\", fontproperties = myfont)xlim(0, 11)ylim(800, 2200)plot(t, y1, 'b-')plot(t, y2, 'g--')plot(t, y3, 'r-')savefig('20180623a4.png')show() 杜邦恒等式$$ROE = \\frac{Net \\ income}{Sales} \\times \\frac{Sales}{Total \\ Assets}\\times \\frac{Total \\ Assets}{Book value of Equity}$$ IBM、DELL和WMT三家公司的相关数据如下表： Ticker Fiscal Year Ending Date ROE Gross Profit Margin Assets Turnover Equity Multiplier IBM 2012-12-31 0.8804 0.1589 0.8766 6.3209 DELL 2013-02-01 0.2221 0.0417 1.1977 4.4513 WMT 2013-01-31 0.2227 0.0362 2.3099 2.6604 Python代码如下12345678910111213141516171819202122232425262728import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.font_manager import *ind = np.arange(3) # ind = array([0, 1, 2])myfont = FontProperties(fname = '/Library/Fonts/Songti.ttc')rcParams['savefig.dpi'] = 1200rcParams['figure.dpi'] = 1200matplotlib.rcParams['axes.unicode_minus'] = Falseplt.title(u'杜邦恒等式', fontproperties = myfont)plt.xlabel(u'公司', fontproperties = myfont)ROE = [0.88, 0.22, 0.22]a = [0.16, 0.04, 0.036]b = [0.88, 1.12, 2.31]c = [6.32, 4.45, 2.66]width = 0.45p1 = plt.bar(ind, a, width, color = 'b')p2 = plt.bar(ind, b, width, color = 'r', bottom = a)p3 = plt.bar(ind, c, width, color = 'y', bottom = b)plt.xticks(ind, ['IBM', 'DELL', 'WMT'])plt.figtext(0.2, 0.85, 'ROE = 0.88')plt.figtext(0.5, 0.7, 'ROE = 0.22')plt.figtext(0.8, 0.6, 'ROE = 0.22')plt.figtext(0.2, 0.75, 'Ptofit Marigin = 0.16')plt.figtext(0.5, 0.5, \"0.41\")plt.figtext(0.8, 0.4, \"0.036\")plt.ylim(0, 8)savefig('20180623c2.png')plt.show() 需要注意的是，不同于Stata中文本位置的指定，这里的文本位置是用百分比的。 NPV&amp;IRR123456789101112131415161718192021from scipy import *from matplotlib.pyplot import *from matplotlib.font_manager import *matplotlib.rcParams['axes.unicode_minus'] = Falsemyfont = FontProperties(fname = '/Library/Fonts/Songti.ttc')rcParams['savefig.dpi'] = 1000rcParams['figure.dpi'] = 1000cashFlows = [-100, 50, 60, 70]rate = []mynpv = []x = (0, 0.7)y = (0, 0)for i in range(1, 70): rate.append(0.01*i) mynpv.append(npv(0.01*i, cashFlows[0:]))plot(rate, mynpv), plot(x, y)xlabel(u'贴现率', fontproperties = myfont)ylabel('NPV')title(u'NPV与折现率', fontproperties = myfont)savefig('20180623c3.png')show() 含两个的IRR的现金流123456789101112131415161718import scipy as spimport matplotlib.pyplot as pltcashFlows = [504, -432, -432, -432, 822]rate = []mynpv = []x = [0, 0.3]y = [0, 0]for i in range(1, 30): rate.append(0.01*i) mynpv.append(sp.npv(0.01*i, cashFlows[0:]))plt.plot(x, y), plt.plot(rate, mynpv)plt.title('Two IRR')plt.xlabel('Discount rate')plt.ylabel('NPV')rcParams['figure.dpi'] = 1000rcParams['savefig.dpi'] = 1000savefig('20180623c4.png')plt.show() 颜色选择123456789101112131415161718192021222324import matplotlib.pyplot as pltA_EPS = (5.02, 4.54, 4.18, 3.73)B_EPS = (1.35, 1.88, 1.35, 0.73)ind = np.arange(len(A_EPS)) # x的位置width = 0.4fig, ax = plt.subplots()A_std = B_std = (2, 2, 2, 2)rects1 = ax.bar(ind, A_EPS, width, color = 'r', yerr = A_std)rects2 = ax.bar(ind, B_EPS, width, color = 'y', yerr = B_std)ax.set_xlabel('Year')ax.set_ylabel('EPS')ax.set_title('Diluted EPS Excluding Extraordinary Iterms')ax.set_xticks(ind+width)ax.set_xticklabels(('2012', '2013', '2014', '2015'))ax.legend((rects1[0], rects2[0]), ('WMT', 'DELL'))def autolabel(rects): for rect in rects: height = rect.get_height() ax.text(rect.get_x() + rect.get_width()/2., 1.05 * height, '%d' % int(height), ha = 'center', va = 'center')autolabel(rects1)autolabel(rects2)plt.show() 一些颜色代码： Letters Color Chinese name Letters Color Chinese name ‘b’ Blue 蓝色 ‘m’ Magenta 品红 ‘g’ Green 绿色 ‘y’ Yellow 黄色 ‘r’ Red 红色 ‘k’ Black 黑色 ‘c’ Cyan 青色 ‘w’ White 白色 一些形状代码: Character Chinese name Character Chinese name ‘-‘ 实线 ‘3’ 向左的三角形 ‘–’ 虚线 ‘4’ 向右的三角形 ‘-.’ 虚线-点 ‘s’ 正方形 ‘:’ 点线 ‘p’ ⭐️(pentagon) ‘.’ 点 ‘*’ * ‘,’ 像素点 ‘h’ 六边形(hexagon) ‘o’ ⭕️ ‘H’ 六边形(hexagon) ‘v’ 向下的三角形 ‘+’ + ‘^’ 向上的三角形 ‘x’ x ‘&lt;’ 向左的三角形\u001f ‘D’ 💎 ‘&gt;’ 向右的三角形 ‘d’ Thin 💎 ‘1’ 向下的三角形 竖线 竖线 ‘2’ 向上的三角形 ‘_’ _ 投资组合的分散效应比较均值方差12345678import numpy as npret_A = [0.102, -0.02, 0.213, 0.12, 0.13]ret_B = [0.1062, 0.23, 0.045, 0.234, 0.113]p = (np.array(ret_A) + np.array(ret_B))/2round(np.mean(ret_A), 3), round(np.mean(ret_B), 3), round(p.mean(), 3)Out[16]: (0.109, 0.146, 0.127)round(np.std(ret_A), 3), round(np.std(ret_B), 3), round(p.std(), 3)Out[17]: (0.075, 0.074, 0.027) 图示1234567891011121314151617181920212223import numpy as npimport matplotlib.pyplot as pltfrom matplotlib import rcParamsyear = [2009, 2010, 2011, 2012, 2013]ret_A = [0.102, -0.02, 0.213, 0.12, 0.13]ret_B = [0.1062, 0.23, 0.045, 0.234, 0.113]p = (np.array(ret_A) + np.array(ret_B))/2plt.figtext(0.2, 0.65, \"Stock A\")plt.figtext(0.15, 0.4, \"Stock B\")plt.xlabel('Year')plt.ylabel('Returns')plt.plot(year, ret_A, lw = 2)plt.plot(year, ret_B, lw = 2)plt.plot(year, p, lw = 2)plt.title('Individual stocks vs. an equal-weighted 2-stock portfolio')plt.annotate('Equal-weighted Portfolio', xy = (2010, 0.1), xytext = (2011, 0), arrowprops = dict(facecolor = 'black', shrink = 0.05))plt.ylim(-0.1, 0.3)rcParams['savefig.dpi'] = 1000plt.savefig('20180623c6.png')plt.show() 计算相关系数12345import scipy as spsp.corrcoef(ret_A, ret_B)Out[19]:array([[ 1. , -0.74583429], [-0.74583429, 1. ]]) 投资组合的分散程度与风险123456789101112131415161718192021222324252627282930from matplotlib.pyplot import *n=[1,2,4,6,8,10,12,14,16,18,20,25,30,35,40,45,50,75,100,200,300,400,500,600,700,800,900,1000]port_sigma=[0.49236,0.37358,0.29687,0.26643,0.24983,0.23932,0.23204,0.22670,0.22261,0.21939,0.21677,0.21196,0.20870,0.20634,0.20456,0.20316,0.20203,0.19860,0.19686,0.19432,0.19336,0.19292,0.19265,0.19347,0.19233,0.19224,0.19217,0.19211,0.19158]xlim(0, 50)ylim(0.1, 0.4)hlines(0.19217, 0, 50, color = 'r', linestyles = '--')annotate('', xy = (5, 0.19), xycoords = 'data', xytext = (5, 0.28), textcoords = 'data', arrowprops = &#123;'arrowstyle':'&lt;-&gt;'&#125;)annotate('', xy = (30, 0.19), xycoords = 'data', xytext = (30, 0.1), textcoords = 'data', arrowprops = &#123;'arrowstyle':'&lt;-&gt;'&#125;)annotate('Total portfolio risk', xy = (5, 0.3), xytext = (25, 0.35), arrowprops = dict(facecolor = 'black', shrink = 0.02))figtext(0.15, 0.4, \"Diversiable risk\")figtext(0.65, 0.25, \"Nondiversiable risk\")plot(n[0:17], port_sigma[0:17])title('Relationship between n and portfolio risk')xlabel(\"Number of stocks in a portfolio\")ylabel(\"Ratio of Portfolio std to std one stock\")rcParams['figure.dpi'] = 1000rcParams['savefig.dpi'] = 1000savefig('20180623c7.png')show() 理解货币的时间价值12345678910111213141516171819202122232425262728293031323334from matplotlib.pyplot import *from matplotlib import rcParamsfig1 = figure(facecolor='white')ax1 = axes(frameon = False)ax1.set_frame_on(False)ax1.get_xaxis().tick_bottom()ax1.axes.get_yaxis().set_visible(False)x = range(0, 11, 2)x1 = range(len(x), 0, -1)y = [0]*len(x)annotate(\"Today's value of $100 received today\", xy = (0, 0), xytext = (2, 0.1), arrowprops = dict(facecolor = 'black', shrink = 0.02))annotate(\"Today's value of $100 received in 2 years\", xy = (2, 0.00005), xytext = (3.7, 0.08), arrowprops = dict(facecolor = 'black', shrink = 0.02))annotate(\"received in 4 years\", xy = (4, 0.00005), xytext = (5.3, 0.06), arrowprops = dict(facecolor = 'black', shrink = 0.02))annotate(\"received in 10 years\", xy = (10, -0.00005), xytext = (6, -0.06), arrowprops = dict(facecolor = 'black', shrink = 0.02))s = [50*2.5**n for n in x1];title(\"Time value of money\")xlim(-2, 11)xlabel(\"Time (number of years)\")scatter(x, y, s = s)rcParams['savefig.dpi'] = 800savefig('20180623c8.png')show() 插入图片1234567import matplotlib.pyplot as pltimport matplotlib.cbook as cbookimage_file = cbook.get_sample_data('/Users/mr.cheng/Desktop/Python_for_Finance/20180623c5.png')image = plt.imread(image_file)plt.imshow(image)plt.savefig('20180623c9.png')plt.show()","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.czxa.top/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.czxa.top/tags/Python/"}]},{"title":"Python for Finance Chapter4~6","slug":"Python_for_Finance_Chapter4~6","date":"2018-06-21T10:49:32.000Z","updated":"2018-07-05T02:46:57.332Z","comments":true,"path":"posts/19677/","link":"","permalink":"http://www.czxa.top/posts/19677/","excerpt":"Chapter4和Chapter5内容比较简单，Chapter6介绍了Numpy包和Scipy包。从这篇博客开始，以后的博客基本都会提供PDF版本下载：Python_for_Finance_Chapter4~6.pdf","text":"Chapter4和Chapter5内容比较简单，Chapter6介绍了Numpy包和Scipy包。从这篇博客开始，以后的博客基本都会提供PDF版本下载：Python_for_Finance_Chapter4~6.pdf Chapter4: 13 Lines of Python to Price a Call option一个BS看涨期权定价模型123456789101112131415161718192021222324252627def CND(X): from math import sqrt, exp, pi (a1, a2, a3, a4, a5) = (0.31938153, -0.356563782, 1.781477937, -1.821255978, 1.330274429) L = abs(X) K = 1.0/(1.0+0.2316419*L) w = 1.0 - 1.0/sqrt(2*pi)*exp(-L*L/2.)*(a1*K+a2*K*K+a3*pow(K,3)+a4*pow(K,4)+a5*pow(K,5)) if X &lt; 0: w = 1.0 - w return wdef bs_call(S, X, T, r, sigma): \"\"\" BS看涨期权定价模型 :param S: 股票价格 :param X: 期权执行价格 :param T: 到期时间 :param r: 无风险利率 :param sigma: 股价波动率 :return: 看涨期权的理论价格 \"\"\" from math import sqrt, log, exp d1 = (log(S/X) + (r + sigma*sigma/2.)*T)/(sigma*sqrt(T)) d2 = d1 - sigma * sqrt(T) return S * CND(d1) - X * exp(-r*T) * CND(d2)bs_call(40, 42, 0.5, 0.1, 0.2)Out[3]: 2.2777859030683096 更多关于累积正态分布函数计算的方法可以参考上面的一篇博客中的介绍。 Chapter5: Introduction to Modules调用系统时间12import time as tttt.localtime() 查看包的位置12345例如查看numpy包的位置：import numpy as npprint(np.__file__)/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/numpy/__init__.py Chapter6: Introduction to NumPy and SciPynumpy使用示例numpy的数组\b只能包含相同格式的元素。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import numpy as npx = np.array([[1,2,3], [4,5,6]]) # 两行三列的数组np.size(x) # x中的元素总个数Out[4]: 6np.size(x, 1) # x的列数Out[5]: 3np.std(x) # x中所有元素的标准差Out[6]: 1.707825127659933np.std(x, 1) # 每行元素的标准差Out[7]: array([ 0.81649658, 0.81649658])x.sum() # x中所有元素的和Out[8]: 21np.random.rand(50) # 生成50个均匀分布的[0, 1]的随机数Out[9]:array([ 0.735929 , 0.48371909, 0.48319465, 0.80330098, 0.71204551, 0.45927359, 0.21042451, 0.34032225, 0.86585374, 0.9184681 , 0.25244703, 0.4655904 , 0.573158 , 0.69078721, 0.28420257, 0.01175873, 0.37011963, 0.05603916, 0.95709586, 0.95434385, 0.69367399, 0.4001506 , 0.25661519, 0.81710797, 0.09105194, 0.71402868, 0.90230726, 0.64391132, 0.14300242, 0.57655021, 0.56516528, 0.78893125, 0.67095094, 0.14877558, 0.65462795, 0.82230541, 0.90485454, 0.57629818, 0.64061762, 0.5215908 , 0.6283539 , 0.31299468, 0.78966549, 0.80825757, 0.22523762, 0.02748282, 0.26128921, 0.36114289, 0.14665284, 0.68495554])np.random.normal(size = 100) # 生成100个正态分布的随机数Out[10]:array([-0.7786169 , -0.19875422, -0.40590406, -0.45937584, -0.95609522, 2.22147808, -0.48074239, -1.13044399, -0.08728271, 0.04701358, -0.10057447, -0.00421842, -0.2200504 , 0.00709479, 0.39573333, 0.04569029, -0.3109542 , 2.09839644, -1.67404649, 1.49882489, -0.12399919, 0.51649219, 0.36264737, 1.1300972 , -1.7555352 , -0.05032842, -0.32048993, -1.18079056, -1.67942396, 0.10823867, 1.55580051, 0.42273131, -1.77889866, -1.1721452 , 1.06275237, -1.02741104, 0.81434569, -0.21687411, 2.00752145, -1.78950106, -1.31966175, 1.85773124, -0.01305868, 1.03553374, 0.55989939, -1.07668277, 2.52250637, -1.78675082, -0.51463924, 0.84409031, 0.11243911, 1.85509026, -0.74423967, -0.55736923, 0.0502106 , -1.13825231, 0.03538882, -1.19465868, -1.62242723, -1.14388286, 1.46096833, 1.60316355, 0.16674316, -1.34344703, 0.41835526, -0.69601261, -0.19510063, -0.83536413, -0.31742093, 0.564493 , 0.94157268, -0.4884695 , 1.43735333, 1.45317239, -1.00098718, 0.6469232 , 0.56245913, -0.09012203, 0.38660999, 1.64892469, 0.23480097, -0.59815152, 0.33332819, 0.19106819, -0.53014824, 0.08541082, -0.2381628 , 2.04182807, 0.69091784, -1.5004019 , -0.94285749, 1.70695792, -1.48779331, -1.38634819, 0.14300425, -0.60616028, 0.16554427, -0.17268446, 0.17657647, 0.11291312])np.array(range(0,100), float)/100 # 生成 0.00, 0.01, 0.02 ··· 0.99, 1.00的序列Out[11]:array([ 0. , 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1 , 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2 , 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3 , 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4 , 0.41, 0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.5 , 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.6 , 0.61, 0.62, 0.63, 0.64, 0.65, 0.66, 0.67, 0.68, 0.69, 0.7 , 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77, 0.78, 0.79, 0.8 , 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88, 0.89, 0.9 , 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99])np.array([100, 0.1, 2], float) # 一个数组中包含的元素应该是同一个格式的Out[12]: array([ 100. , 0.1, 2. ])# 改变数组的元素格式y = [1,2,3,20]y = np.array(y, dtype = float)yOut[15]: array([ 1., 2., 3., 20.]) scipy包使用示例NPV函数12345678910import scipy as spcashflows = [-100, 50, 40, 20, 10, 50]npv = sp.npv(0.1, cashflows) # 计算NPVround(npv, 2)Out[75]: 31.41# scipy包中的npv函数是一个真实的NPV函数c = [-100]sp.npv(0.1, c)Out[78]: -100.0# 注意，实际上Excel中的NPV函数是个PV函数 PMT函数30年、年息4.5%、总额250000的贷款，月付是多少？123pmt = sp.pmt(0.045/12, 30*12, 250000, when = 'end')round(pmt, 2)Out[83]: -1266.71 PV函数和FV函数12345678sp.pv(0.1, 1, 0, 100) ## 100块1年前的现值，pmt = 0Out[85]: -90.909090909090907sp.fv(0.1, 1, 0, 100) ## 100块1年后的终值，pmt = 0Out[86]: -110.00000000000001sp.pv(0.1, 2, 100, 0, when='end') ## 年金现值（默认期末支付）Out[87]: -173.55371900826461sp.pv(0.1, 2, 100, 0, when='start') ## 应付年金现值（期初年金）Out[88]: -190.90909090909108 收益率的算术均值和几何均值$$Arithmetic\\ mean = \\frac{\\sum_{i =1}^{n}R_i}{n}$$$$Geometric\\ mean = \\left[ \\prod_{i=1}^{n}(1+R_i) \\right]^{1/n} - 1$$12345ret = sp.array([0.1, 0.05, -0.02])sp.mean(ret) # 算术均值Out[91]: 0.043333333333333342pow(sp.prod(ret + 1), 1./len(ret)) - 1 # 几何均值Out[92]: 0.042163887067679262 sp.unique函数：查找奇异值123sp.unique([2,3,4,4,4,6,6])Out[94]: array([2, 3, 4, 6])` sp.median函数：中位数12sp.median([2,3,4,5,6,6,7,10])Out[96]: 5.5 显示numpy和scipy中的所有函数12345678x = np.array(dir(np))len(x)Out[102]: 613x[200:210]Out[103]:array(['diagonal', 'diff', 'digitize', 'disp', 'divide', 'division', 'divmod', 'dot', 'double', 'dsplit'], dtype='&lt;U25') numpy包中的数组生成函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import numpy as np# 生成10个0的数组np.zeros(10)Out[63]: array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])# 生成3行2列的数组np.zeros((3,2), dtype=float)Out[65]:array([[ 0., 0.], [ 0., 0.], [ 0., 0.]])# 生成4行3列全是1的数组np.ones((4,3), dtype=float)Out[67]:array([[ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.]])# 生成0-9的序列np.array(range(10), dtype=float)Out[69]: array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])# 生成4维的单位数组np.identity(4)Out[71]:array([[ 1., 0., 0., 0.], [ 0., 1., 0., 0.], [ 0., 0., 1., 0.], [ 0., 0., 0., 1.]])# 生成4维的单位数组np.eye(4)Out[73]:array([[ 1., 0., 0., 0.], [ 0., 1., 0., 0.], [ 0., 0., 1., 0.], [ 0., 0., 0., 1.]])# eye的更多用法np.eye(4, k = 1)Out[75]:array([[ 0., 1., 0., 0.], [ 0., 0., 1., 0.], [ 0., 0., 0., 1.], [ 0., 0., 0., 0.]])np.eye(4, k = 2)Out[76]:array([[ 0., 0., 1., 0.], [ 0., 0., 0., 1.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]])# from 1 to 19 interval 3np.arange(1, 20, 3, float)Out[78]: array([ 1., 4., 7., 10., 13., 16., 19.])# 2x3的数组np.array([[2,2,2],[3,3,3]])Out[80]:array([[2, 2, 2], [3, 3, 3]])# 生成一个类似的全为0的数组np.zeros_like(np.array([[2,2,2],[3,3,3]]))Out[82]:array([[0, 0, 0], [0, 0, 0]])# 生成一个类似的全为1的数组np.ones_like(np.array([[2,2,2],[3,3,3]]))Out[84]:array([[1, 1, 1], [1, 1, 1]]) numpy包中的\b运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# 加法c1 = np.array([-100, 50, 20])c2 = np.array([-80, 100, 120])c1 + c2Out[88]: array([-180, 150, 140])# 乘法x1 = np.array([[1,2,3],[4,5,6],[7,8,9]])np.dot(x1, x1) # 点乘Out[91]:array([[ 30, 36, 42], [ 66, 81, 96], [102, 126, 150]])x1*x1 # 叉乘Out[92]:array([[ 1, 4, 9], [16, 25, 36], [49, 64, 81]])# 数组与矩阵之间的转换np.matrix(x1)Out[94]:matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])np.array(np.matrix(x1))Out[95]:array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])# 一些函数x = np.array([[1,2,3],[4,5,6],[7,8,9]])## 下面两种方式是等价的x.sum()Out[99]: 45np.sum(x)Out[100]: 45x.min()Out[101]: 1np.min(x)Out[102]: 1x.mean()Out[103]: 5.0x.var()Out[104]: 6.666666666666667x.argmin() # 返回最小值的位置Out[105]: 0x.argmax()Out[106]: 8x.clip(min = 2) # 设定最低门限，低于门限值的都会被替换成门限值Out[107]:array([[2, 2, 3], [4, 5, 6], [7, 8, 9]])x.clip(max = 3) # 设定最高门限，高于门限值的都会被替换成门限值Out[108]:array([[1, 2, 3], [3, 3, 3], [3, 3, 3]])x.diagonal() # 返回x的对角线组成的数组Out[109]: array([1, 5, 9])x.tolist() # 返回列表Out[110]: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]x.transpose() # 转置Out[111]:array([[1, 4, 7], [2, 5, 8], [3, 6, 9]])x.flatten() # 返回x的元素组成的列数组Out[112]: array([1, 2, 3, 4, 5, 6, 7, 8, 9])c = np.array([-100, 30, 50, 100, 30, 40])c.min()Out[114]: -100c.argmin()for cash in c: print(cash)Out[113]:-10030501003040 使用scipy包中的累积正态分布函数重新编写BS期权定价公式123456789101112131415161718192021# scipy中的累积正态分布函数from scipy.stats import normnorm.cdf(0)# 重新编写BS期权定价公式from scipy import log, exp, sqrt, statsdef bs_call_new(S = 40, X = 40, T = 1, r = 0.03, sigma = 0.2): \"\"\" BS看涨期权定价公式 BS看涨期权定价模型 :param S: 股票价格，默认为40 :param X: 期权执行价格，默认为40 :param T: 到期时间，默认为1 :param r: 无风险利率，默认为0.03 :param sigma: 股价波动率，默认为0.2 :return: 看涨期权的理论价格 \"\"\" d1 = (log(S/X) + (r + sigma*sigma/2.)*T)/(sigma*sqrt(T)) d2 = d1 - sigma*sqrt(T) return (S*stats.norm.cdf(d1) - X*exp(-r*T)*stats.norm.cdf(d2))bs_call_new()Out[118]: 3.7653613535412056 numpy数组中的逻辑运算123456789101112131415# 数组中的逻辑运算import numpy as npx = np.array([True, False, True, False], bool)any(x) # True if any element in x is True.Out[122]: Trueall(x) # True if all elements in x is True.Out[123]: Falsec = np.array([-100, 50, 40, 30, 100, -5])c &gt; 0Out[125]: array([False, True, True, True, True, False], dtype=bool)np.logical_and(c &gt; 0, c &lt; 60)Out[126]: array([False, True, True, True, False, False], dtype=bool)# 选择c中于0的子数组c[(c &gt; 0)]Out[128]: array([ 50, 40, 30, 100]) scipy包中的统计量1234567891011121314151617181920212223242526from scipy import statsimport numpy as nplen(np.array(dir(stats)))Out[132]: 246# 设定种子产生正态随机数np.random.seed(124)x = np.random.normal(0, 1, 100)# 计算skewnessstats.skew(x)Out[137]: -0.22970945459723696# 检验均值为0的t统计量和p值stats.ttest_1samp(x, 0)Out[139]: Ttest_1sampResult(statistic=1.1763312806843913, pvalue=0.24228334454436026)# 从均匀分布中取值np.random.uniform(low = 0.0, high = 1.0, size = 100)Out[141]:array([ 0.19275227, 0.00719085, 0.60879808, 0.34413601, 0.46909886, 0.41924856, 0.70729132, 0.19932869, 0.53038474, 0.65138402, ······ 0.72680799, 0.7399658 , 0.61201165, 0.47996572, 0.04460141, 0.38995655, 0.71368747, 0.54200784, 0.91374774, 0.01945046, 0.87729023, 0.63369815, 0.94858029, 0.5828617 , 0.25943912])np.random.randint(low = 1, high = 500, size = 20)Out[142]:array([232, 434, 258, 32, 211, 112, 326, 265, 71, 301, 193, 474, 240, 161, 479, 438, 75, 314, 454, 391]) scipy包中的插值1234567891011121314import numpy as npimport matplotlib.pyplot as pltfrom scipy.interpolate import interp1dx = np.linspace(0, 10, 10) # 0-10 长度为10xy = np.exp(-x/3.0)f = interp1d(x, y)f2 = interp1d(x, y, kind = 'cubic')# help(interp1d)# kind可选项 'linear', 'nearest', 'zero', 'slinear', 'quadratic', 'cubic'xnew = np.linspace(0, 10, 40)plt.plot(x, y, 'o', xnew, f(xnew), '-', xnew, f2(xnew), '--')plt.legend(['data', 'linear', 'cubic'], loc = 'best')plt.show() 使用scipy包解方程$$\\left\\{\\begin{array}{lr}&amp; x +2y+5z = 10 \\\\&amp; 2x+5y+z = 8 \\\\&amp; 2x+3y+8z =5 \\\\\\end{array} \\right.$$ 12345678910111213141516import scipy as spimport numpy as npA = sp.mat('[1 2 5; 2 5 1; 2 3 8]')b = sp.mat('[10; 8; 5]')## A.I表示矩阵A的逆A.I*bOut[148]:matrix([[-22.45454545], [ 10.09090909], [ 2.45454545]])## numpy包中也提供了解方程的函数np.linalg.solve(A, b)Out[150]:matrix([[-22.45454545], [ 10.09090909], [ 2.45454545]]) 随机数种子1234567891011121314151617181920212223import scipy as spsp.random.rand(10) # 10 random numbers from [0, 1]Out[152]:array([ 0.30753252, 0.18513044, 0.65942764, 0.46920167, 0.52875454, 0.16858862, 0.00986553, 0.69832679, 0.4512412 , 0.75672126])sp.random.rand(5, 2) # random numbers 5 by 2 arrayOut[153]:array([[ 0.88412845, 0.95585649], [ 0.28965947, 0.36676156], [ 0.21277316, 0.20550993], [ 0.43206176, 0.69406982], [ 0.95576823, 0.72806124]])sp.random.normal(size=100)Out[154]:array([ -8.91784557e-01, 1.66045973e+00, 4.24440411e-01, -1.40459412e+00, -7.24540377e-01, 3.79290558e-01, ······ 8.83488474e-01, -2.18699157e-01, -1.05690114e+00, -1.45189444e+00, 8.74852067e-02, -1.18728511e+00, 2.91119440e-01])sp.random.seed(123456)sp.random.rand(5)Out[156]: array([ 0.12696983, 0.96671784, 0.26047601, 0.89723652, 0.37674972]) 从一个包中搜索一个函数123456789import numpy as npx = np.array(dir(np))for k in x: if (k.find(\"uni\") != -1): print(k)unicodeunicode_union1dunique 最优化123456789import scipy.optimize as spopdef my_f(x): return 3 + x**2spop.fmin(my_f, 5) # 5是初始值Optimization terminated successfully. Current function value: 3.000000 Iterations: 20 Function evaluations: 40Out[160]: array([ 0.]) CAPM123456789101112from scipy import statsstock_ret = [0.065, 0.0265, -0.0593, -0.001, 0.0346]mkt_ret = [0.055, -0.09, -0.041, 0.045, 0.022]beta, alpha, r_value, p_value, std_err = stats.linregress(stock_ret, mkt_ret)print(beta, alpha)0.507743187877 -0.00848190035246stats.linregress(stock_ret, mkt_ret)Out[168]: LinregressResult(slope=0.50774318787708084, intercept=-0.0084819003524623845, rvalue=0.38455905003823676, pvalue=0.52271552390894616, stderr=0.70367055432215686)print(\"R^2 =\" , r_value**2)R^2 = 0.147885662966print(\"p-value =\", p_value)p-value = 0.522715523909 读取文本文件我自己做了个平安银行过去40天的股价数据文件pingan.csv。12345678910111213141516171819202122232425262728293031f = open(\"pingan.csv\", \"r\")data = f.readlines()type(data)Out[174]: listdataOut[175]:['stkcd,date,stknme,clsprc,hiprc,lowprc,opnprc,rit,turnover,volume,transaction,tcap,mcap\\n', '1,2018-04-23,pingan,11.57,11.61,11.26,11.3,.019383,.63260001,10.7028935,1228544000,198661659505,195741343744\\n', ······ '1,2018-06-20,pingan,9.9099998,9.9499998,9.7600002,9.8699999,.004053,.4447,7.6363731,752950720,170158776637,170157229240\\n']import numpy as npnp.loadtxt(\"pingan.csv\", delimiter=\",\") ## 这个出错，没能找到原因# genfromtxt()函数会把非标准值例如3.5%视为NAnp.genfromtxt(\"pingan.csv\", delimiter=\",\")Out[179]:array([[ nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan], [ 1.00000000e+00, nan, nan, 1.15700000e+01, 1.16100000e+01, 1.12600000e+01, 1.13000000e+01, 1.93830000e-02, 6.32600010e-01, 1.07028935e+01, 1.22854400e+09, 1.98661660e+11, 1.95741344e+11], ······ [ 1.00000000e+00, nan, nan, 9.90999980e+00, 9.94999980e+00, 9.76000020e+00, 9.86999990e+00, 4.05300000e-03, 4.44700000e-01, 7.63637310e+00, 7.52950720e+08, 1.70158777e+11, 1.70157229e+11]])","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.czxa.top/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.czxa.top/tags/Python/"}]},{"title":"Python for Finance Chapter1~3","slug":"Python_for_Finance_Chapter1~3","date":"2018-06-17T04:49:32.000Z","updated":"2018-07-28T10:52:05.517Z","comments":true,"path":"posts/54264/","link":"","permalink":"http://www.czxa.top/posts/54264/","excerpt":"本文PDF版本下载：Python_for_Finance_Chapter1~3.pdf这本书介绍了Python在金融领域的基本应用，非常适合入门。为了保证学习效果，我决定好好记笔记。下面是这本书的下载链接，欢迎一起学习：Python_for_Finance.pdf","text":"本文PDF版本下载：Python_for_Finance_Chapter1~3.pdf这本书介绍了Python在金融领域的基本应用，非常适合入门。为了保证学习效果，我决定好好记笔记。下面是这本书的下载链接，欢迎一起学习：Python_for_Finance.pdf Chapter1: Python的安装与介绍Python是大小写敏感的查看帮助文档1234567891011121314help()👇结果help&gt; keywordsHere is a list of the Python keywords. Enter any keyword to get more help.False def if raiseNone del import returnTrue elif in tryand else is whileas except lambda withassert finally nonlocal yieldbreak for not class from or continue global pass 在PyCharm中，选中某行代码然后Shift+Alt+E即可逐行运行代码。 查看和调用Python的版本1234import syssys.version👇结果Out[2]: '3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) \\n[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]' Chapter2: 把Python当成普通计算器使用变量定义不需要事先声明12pv = 22pv+2 ##使用dir()查看已有的变量和函数1234567891011121314151617181920212223242526272829303132dir()👇结果Out[4]:['In', 'Out', '_', '_2', '_3', '__', '___', '__builtin__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', '_dh', '_i', '_i1', '_i2', '_i3', '_i4', '_ih', '_ii', '_iii', '_oh', 'exit', 'get_ipython', 'pv', 'quit', 'sys'] 删除一个变量1del pv 幂运算1232**3👇结果Out[6]: 8 真正的幂函数123pow(2, 3)👇结果Out[7]: 8 关于局部变量和全局变量的LEGB规则更多内容参考这篇博客：Python中的LEGB规则 Items meanings L Local refers to names assigned in any way within a function (def) and not declared global in that function. E Enclosing refers to enclosing function locals, such as names, in the local scope of any and all enclosing function (def). G Global refers to names such as assigned at the top level of a module or declared as global variable within a function defined by def. B Build-in refers to names pre-assigned in the build-in-modules, such as open, range, and SyntaxError. 用中文来说就是： Items meanings Local 可能是在一个函数或者类方法内部。 Enclosed 可能是嵌套函数内，比如说 一个函数包裹在另一个函数内部。 Global 代表的是执行脚本自身的最高层次。 Built-in 是Python为自身保留的特殊名称。 pow()函数和**的区别12345678help(pow)👇结果Help on built-in function pow in module builtins:pow(x, y, z=None, /) Equivalent to x**y (with two arguments) or x**y % z (with three arguments) Some types, such as ints, are able to use a more efficient algorithm when invoked using the three argument form. 也就是说pow()函数里面可以使用三个参数，如果使用三个参数:$$pow(x, y, z) = mod(x^y, z)$$ 选择精确度123456789print(7/3)payment = 7/3payment1 = round(payment, 2)print(payment)print(payment1)👇结果2.33333333333333352.33333333333333352.33 不过需要注意的是，这里的round()函数会事实上改变精确度，因此需要谨慎使用。如果round()没有指定精确度，默认返回一个整数。 import mathvs. from math import *使用第一种方式后，后面引用该包中的函数仍然需要加上前缀math.，而使用第二种方式之后不再需要。 判断一个变量的类型——type()123type(payment)👇结果Out[13]: float 使用下划线表示上一个表达式12345678910111213x = 1.56y = 5.77x+y👇结果Out[21]: 7.339+_👇结果Out[22]: 16.33round(_, 1)👇结果Out[23]: 16.3 大写函数：upper()1234x = 'This is a sentence'x.upper()👇结果Out[24]: 'THIS IS A SENTENCE' 列示所有的字符串函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990dir('')Out[25]:👇结果['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']# 例如首字母大写函数的帮助文件 help(''.capitalize) 👇结果 Help on built-in function capitalize: capitalize(...) method of builtins.str instance S.capitalize() -&gt; str Return a capitalized version of S, i.e. make the first character have upper case and the rest lower case. 元组——tuple元组是一个常量，其中的数值不可修改。12345678910111213141516171819202122x = ('czx', 21)len(x)👇结果Out[30]: 2x[0]👇结果Out[31]: 'czx'type(x[1])👇结果Out[32]: intz = ()type(z)👇结果Out[34]: tupley = (1, )type(y)👇结果Out[36]: tuplex = (1) ===&gt;这个是作为int的type(x)👇结果Out[38]: int 元组的格式化输出123x = ('czx', 21)print('我的名字是 %s, 年龄 %d 岁。' % x)我的名字是 czx, 年龄 21 岁。 把Python作为一个金融计算器来使用首先需要编写一个含各种算式的脚本：fin101.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190def pv_f(fv, r , n): \"\"\" 现值函数。 :param fv: 终值 :param r: 贴现率 :param n: 期数 :return: 现值 \"\"\" return fv/((1+r)**n)def dir2(path = '/Users/mr.cheng/Desktop/Python_for_Finance'): \"\"\" 列示某个路径上的所有文件： :param path: 路径，默认为'/Users/mr.cheng/Desktop/Python_for_Finance' :return: 指定路径上的所有文件名的一个列表 \"\"\" from os import listdir print(listdir(path)) return listdir(path)def pv_perpetuity(c, r): \"\"\" 计算永续现金流的现值 :param c: 每期现金流 :param r: 贴现率 :return: 现值 \"\"\" return c/rdef pv_growing_perpetuity(c, r, g): \"\"\" 计算增长现金流的现值。 :param c: 第一笔现金流 :param r: 贴现率 :param g: 年金每期增长率 :return: 增长现金流的现值 \"\"\" if(r &lt; g): print(\"r &lt; g !!!\") else: return (c/(r - g))def pv_annuity(c, r, n): \"\"\" 计算普通年金(期初支付)的现值 :param c: 每期支付 :param r: 贴现率 :param n: 期数 :return: 年金现值 \"\"\" return (c/r)(1-1/((1+r)**n))def pv_annuity_due(c, r, n): \"\"\" 计算应付年金(期末支付)现值 :param c: 每期支付 :param r: 贴现率 :param n: 期数 :return: 年金现值 \"\"\" return (c/r)(1-1/((1+r)**n))(1+r)def fv_annuity(c, r, n): \"\"\" 计算普通年金终值 :param c: 每期支付 :param r: 贴现率 :param n: 期数 :return: 年金终值 \"\"\" return (c/r)((1+r)**n - 1)def fv_annuity_due(c, r, n): \"\"\" 计算应付年金终值 :param c: 每期支付 :param r: 贴现率 :param n: 期数 :return: 年金终值 \"\"\" return (c/r)((1+r)**n - 1)(1+r)def pv_growing_annuity(c, n, r, g): \"\"\" 计算增长型年金现值 :param c: 每期支付 :param r: 贴现率 :param n: 期数 :param g: 年金增长率 :return: 年金现值 \"\"\" return (c/r)(1-((1+g)/(1+r))**n)def fv_growing_annuity(c, n, r, g): \"\"\" 计算增长型年金终值 :param c: 每期支付 :param r: 贴现率 :param n: 期数 :param g: 年金增长率 :return: 年金终值 \"\"\" return (c/r)((1+r)**n - (1+g)**n)def EAR(APR, m): \"\"\" 年化百分率转换成有效年利率 :param APR: 年化百分率 :param m: 计息频率 :return: EAR \"\"\" return (1 + APR/m)**m - 1def continuously_compounded_interest_rate(APR, m): \"\"\" APR =&gt; 连续负利率。 exp(R_c) = (1+APR/m)^m ==&gt; R_c = ln[(1+APR/m)^m] :param APR: 年化百分率 :param m: 计息频率 :return: 连续EAR \"\"\" from math import log return log((1+APR/m)^m)def npv_f(rate, cashflows): \"\"\" 计算给定现金流的净现值 :param rate: 贴现率 :param cashflows: 现金流列表 :return: NPV \"\"\" total = 0.0 ## 下面的这种用法非常重要： for i, cashflow in enumerate(cashflows): total += cashflow/(1+rate)**i return totaldef payback_period(cashflows): \"\"\" 计算回收期 :param cashflows: :return: \"\"\" total = 0 for i, cashflow in enumerate(cashflows): total += cashflow if (total &lt; 0): continue else: total_temp = 0.0 # 注意range()函数不包括右边界 for j in range(0, i): total_temp += cashflows[j] total_temp = abs(total_temp) return i-1+total_temp/cashflows[i]def IRR_f(cashflows, interations = 1000): \"\"\" 计算内部收益率 :param cashflows: 现金流列表 :param interations: 迭代次数，默认为1000 :return: \"\"\" rate = 1.0 investment = cashflows[0] for i in range(1, interations+1): rate *= (1-npv_f(rate, cashflows)/investment) return ratedef fin101(): \"\"\" 基本函数： 1. pv_f(fv, r , n) 2. dir2(path = '/Users/mr.cheng/Desktop/Python_for_Finance') 3. pv_perpetuity(c, r) 4. pv_growing_perpetuity(c, r, g) 5. pv_annuity(c, r, n) 6. pv_annuity_due(c, r, n) 7. fv_annuity(c, r, n) 8. fv_annuity_due(c, r, n) 9. pv_growing_annuity(c, n, r, g) 10. fv_growing_annuity(c, n, r, g) 11. EAR(APR, m) 12. continuously_compounded_interest_rate(APR, m) 13. npv_f(rate, cashflows) 14. payback_period(cashflows) 15. IRR_f(cashflows, interations = 1000) 查看帮助文件： 例如pv_f: &gt;&gt;&gt; help(pv_f) \"\"\" 上面的脚本中的回收期计算函数是我自己设计的！下面是这个脚本的使用方法：12from fin101 import *help(fin101) 把我们的项目添加到系统路径中123456789101112131415import sysmyFolder = '/Users/mr.cheng/Desktop/Python_for_Finance'if myFolder not in sys.path: sys.path.append(myFolder)for path in sys.path: print(path)👇结果/Applications/PyCharm.app/Contents/helpers/pydev/Applications/PyCharm.app/Contents/helpers/pydev/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/IPython/extensions/Users/mr.cheng/Desktop/Python_for_Finance","categories":[{"name":"笔记","slug":"笔记","permalink":"http://www.czxa.top/categories/笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.czxa.top/tags/Python/"}]}]}